#
#	modified:   frameworks/native/include/gui/SurfaceTexture.h
#	modified:   frameworks/native/include/ui/PixelFormat.h
#	modified:   frameworks/native/libs/gui/SurfaceTexture.cpp
#
diff --git a/frameworks/native/include/gui/SurfaceTexture.h b/frameworks/native/include/gui/SurfaceTexture.h
index ec73f95..2e55ae7 100644
--- a/frameworks/native/include/gui/SurfaceTexture.h
+++ b/frameworks/native/include/gui/SurfaceTexture.h
@@ -100,6 +100,12 @@ public:
     status_t updateTexImage();
 
 #ifdef STE_HARDWARE
+#ifdef STE_SNDA_HARDWARE
+    // A surface that uses a non-native format requires conversion of
+    // its buffers. This conversion can be deferred until the layer
+    // based on this surface is drawn.
+    status_t updateTexImage(bool deferConversion);
+#endif
     // convert() performs the deferred texture conversion as scheduled
     // by updateTexImage(bool deferConversion).
     // The method returns immediately if no conversion is necessary.
diff --git a/frameworks/native/include/ui/PixelFormat.h b/frameworks/native/include/ui/PixelFormat.h
index 62eb9b4..7ca9fbd 100644
--- a/frameworks/native/include/ui/PixelFormat.h
+++ b/frameworks/native/include/ui/PixelFormat.h
@@ -70,6 +70,9 @@ enum {
     PIXEL_FORMAT_YCBCR42XMBN = HAL_PIXEL_FORMAT_YCBCR42XMBN,
     PIXEL_FORMAT_YCbCr_420_SP = HAL_PIXEL_FORMAT_YCbCr_420_SP,
     PIXEL_FORMAT_YCbCr_420_P = HAL_PIXEL_FORMAT_YCbCr_420_P,
+#ifdef STE_SNDA_HARDWARE
+    PIXEL_FORMAT_YCbCr_422_I = HAL_PIXEL_FORMAT_YCbCr_422_I,
+#endif
 #endif
 };
 
diff --git a/frameworks/native/libs/gui/SurfaceTexture.cpp b/frameworks/native/libs/gui/SurfaceTexture.cpp
index 21f3112..7d458de 100644
--- a/frameworks/native/libs/gui/SurfaceTexture.cpp
+++ b/frameworks/native/libs/gui/SurfaceTexture.cpp
@@ -27,7 +27,9 @@
 #include <GLES2/gl2ext.h>
 
 #include <hardware/hardware.h>
-
+#ifdef STE_HARDWARE
+#include <ui/PixelFormat.h>
+#endif
 #include <gui/IGraphicBufferAlloc.h>
 #include <gui/ISurfaceComposer.h>
 #include <gui/SurfaceComposerClient.h>
@@ -218,7 +220,11 @@ status_t SurfaceTexture::updateTexImage() {
 #define STE_DEFERDBG 0
 #endif
 }
-
+#ifdef STE_HARDWARE
+status_t SurfaceTexture::updateTexImage(bool deferConversion) {
+    return SurfaceTexture::updateTexImage(NULL, deferConversion);
+}
+#endif
 #ifndef STE_HARDWARE
 status_t SurfaceTexture::updateTexImage(BufferRejecter* rejecter) {
 #else
@@ -314,7 +320,11 @@ status_t SurfaceTexture::updateTexImage(BufferRejecter* rejecter, bool deferConv
         }
 #else
         EGLImageKHR image;
+#ifndef STE_SNDA_HARDWARE
         EGLDisplay dpy = eglGetCurrentDisplay();
+#else
+        sp<GraphicBuffer> graphicBuffer;
+#endif
         if (conversionIsNeeded(mEGLSlots[buf].mGraphicBuffer)) {
             mNeedsConversion = deferConversion;
             // If color conversion is needed we can't use the graphic buffers
@@ -357,8 +367,9 @@ status_t SurfaceTexture::updateTexImage(BufferRejecter* rejecter, bool deferConv
                     ST_LOGW("updateTexImage: SurfaceComposer::createGraphicBuffer error=%#04x", res);
                 }
                 mBlitSlots[mNextBlitSlot].mGraphicBuffer = blitBuffer;
-
+#ifndef STE_SNDA_HARDWARE
                 EGLDisplay dpy = eglGetCurrentDisplay();
+#endif
                 image = createImage(dpy, blitBuffer);
                 mBlitSlots[mNextBlitSlot].mEglImage = image;
                 mBlitSlots[mNextBlitSlot].mEglDisplay = dpy;
@@ -392,14 +403,20 @@ status_t SurfaceTexture::updateTexImage(BufferRejecter* rejecter, bool deferConv
             image = mEGLSlots[buf].mEglImage ;
             item.mGraphicBuffer = mEGLSlots[buf].mGraphicBuffer;
             if (image == EGL_NO_IMAGE_KHR) {
+#ifndef STE_SNDA_HARDWARE
                 EGLDisplay dpy = eglGetCurrentDisplay();
+#endif	
                 if (item.mGraphicBuffer == 0) {
                     ST_LOGE("buffer at slot %d is null", buf);
                     return BAD_VALUE;
                 }
                 image = createImage(dpy, item.mGraphicBuffer);
                 mEGLSlots[buf].mEglImage = image;
+#ifndef STE_SNDA_HARDWARE
                 mEglDisplay = dpy;
+#else		
+				mEGLSlots[buf].mEglDisplay = dpy;
+#endif
                 if (image == EGL_NO_IMAGE_KHR) {
                     // NOTE: if dpy was invalid, createImage() is guaranteed to
                     // fail. so we'd end up here.
@@ -1019,7 +1036,12 @@ void SurfaceTexture::dump(String8& result, const char* prefix,
 #ifdef STE_HARDWARE
 bool SurfaceTexture::conversionIsNeeded(const sp<GraphicBuffer>& graphicBuffer) {
     int fmt = graphicBuffer->getPixelFormat();
-    return (fmt == PIXEL_FORMAT_YCBCR42XMBN) || (fmt == PIXEL_FORMAT_YCbCr_420_P);
+    return (fmt == PIXEL_FORMAT_YCBCR42XMBN) || (fmt == PIXEL_FORMAT_YCbCr_420_P)
+#ifdef STE_SNDA_HARDWARE
+            || (fmt == PIXEL_FORMAT_YCbCr_420_SP)
+            || (fmt == PIXEL_FORMAT_YCbCr_422_I)
+#endif
+	;
 }
 
 status_t SurfaceTexture::convert() {
