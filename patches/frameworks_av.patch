#
#	modified:   frameworks/av/camera/CameraParameters.cpp
#	modified:   frameworks/av/include/camera/CameraParameters.h
#	modified:   frameworks/av/include/media/stagefright/ColorConverter.h
#	new file:   frameworks/av/include/media/stagefright/FMRadioSource.h
#	modified:   frameworks/av/include/media/stagefright/MediaDefs.h
#	modified:   frameworks/av/include/media/stagefright/OMXCodec.h
#	modified:   frameworks/av/media/libstagefright/ACodec.cpp
#	modified:   frameworks/av/media/libstagefright/Android.mk
#	modified:   frameworks/av/media/libstagefright/AwesomePlayer.cpp
#	modified:   frameworks/av/media/libstagefright/CameraSource.cpp
#	new file:   frameworks/av/media/libstagefright/FMRadioSource.cpp
#	modified:   frameworks/av/media/libstagefright/MediaDefs.cpp
#	modified:   frameworks/av/media/libstagefright/MediaExtractor.cpp
#	modified:   frameworks/av/media/libstagefright/OMXCodec.cpp
#	new file:   frameworks/av/media/libstagefright/PCMExtractor.cpp
#	modified:   frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp
#	new file:   frameworks/av/media/libstagefright/include/PCMExtractor.h
#	modified:   frameworks/av/media/libstagefright/omx/SoftOMXPlugin.cpp
#
diff --git a/frameworks/av/camera/CameraParameters.cpp b/frameworks/av/camera/CameraParameters.cpp
index 1507c7c..ab74b6f 100644
--- a/frameworks/av/camera/CameraParameters.cpp
+++ b/frameworks/av/camera/CameraParameters.cpp
@@ -150,6 +150,15 @@ const char CameraParameters::SCENE_MODE_BARCODE[] = "barcode";
 const char CameraParameters::PIXEL_FORMAT_YUV422SP[] = "yuv422sp";
 const char CameraParameters::PIXEL_FORMAT_YUV420SP[] = "yuv420sp";
 const char CameraParameters::PIXEL_FORMAT_YUV422I[] = "yuv422i-yuyv";
+#ifdef STE_HARDWARE
+const char CameraParameters::PIXEL_FORMAT_YUV420SPNV12[] = "yuv420spnv12";
+const char CameraParameters::PIXEL_FORMAT_UYV422I[] = "yuv422i-uyvy";
+const char CameraParameters::PIXEL_FORMAT_YUV420MB[] = "yuv420mb";
+const char CameraParameters::PIXEL_FORMAT_YVU422SP[] = "yvu422sp";
+const char CameraParameters::PIXEL_FORMAT_YVU422P[] = "yvu422p";
+const char CameraParameters::PIXEL_FORMAT_YVU420SP[] = "yvu420sp";
+const char CameraParameters::PIXEL_FORMAT_YVU420P[]  = "yvu420p";
+#endif
 const char CameraParameters::PIXEL_FORMAT_YUV420P[]  = "yuv420p";
 const char CameraParameters::PIXEL_FORMAT_RGB565[] = "rgb565";
 const char CameraParameters::PIXEL_FORMAT_RGBA8888[] = "rgba8888";
@@ -164,6 +173,11 @@ const char CameraParameters::FOCUS_MODE_FIXED[] = "fixed";
 const char CameraParameters::FOCUS_MODE_EDOF[] = "edof";
 const char CameraParameters::FOCUS_MODE_CONTINUOUS_VIDEO[] = "continuous-video";
 const char CameraParameters::FOCUS_MODE_CONTINUOUS_PICTURE[] = "continuous-picture";
+#ifdef STE_HARDWARE
+// keys for record stride and sliceheight
+const char CameraParameters::KEY_RECORD_STRIDE[] = "record-stride";
+const char CameraParameters::KEY_RECORD_SLICE_HEIGHT[] = "record-slice-height";
+#endif
 CameraParameters::CameraParameters()
                 : mMap()
 {
diff --git a/frameworks/av/include/camera/CameraParameters.h b/frameworks/av/include/camera/CameraParameters.h
index 863fe48..cd2e356 100644
--- a/frameworks/av/include/camera/CameraParameters.h
+++ b/frameworks/av/include/camera/CameraParameters.h
@@ -599,6 +599,15 @@ public:
     static const char PIXEL_FORMAT_YUV422SP[];
     static const char PIXEL_FORMAT_YUV420SP[]; // NV21
     static const char PIXEL_FORMAT_YUV422I[]; // YUY2
+#ifdef STE_HARDWARE
+    static const char PIXEL_FORMAT_YUV420SPNV12[]; // NV12
+    static const char PIXEL_FORMAT_UYV422I[];
+    static const char PIXEL_FORMAT_YVU422SP[];
+    static const char PIXEL_FORMAT_YVU422P[];
+    static const char PIXEL_FORMAT_YVU420SP[];
+    static const char PIXEL_FORMAT_YVU420P[];
+    static const char PIXEL_FORMAT_YUV420MB[];
+#endif
     static const char PIXEL_FORMAT_YUV420P[]; // YV12
     static const char PIXEL_FORMAT_RGB565[];
     static const char PIXEL_FORMAT_RGBA8888[];
@@ -657,6 +666,11 @@ public:
     // To stop continuous focus, applications should change the focus mode to
     // other modes.
     static const char FOCUS_MODE_CONTINUOUS_PICTURE[];
+#ifdef STE_HARDWARE
+    // keys for record stride and slice height
+    static const char KEY_RECORD_STRIDE[];
+    static const char KEY_RECORD_SLICE_HEIGHT[];
+#endif
 private:
     DefaultKeyedVector<String8,String8>    mMap;
 };
diff --git a/frameworks/av/include/media/stagefright/ColorConverter.h b/frameworks/av/include/media/stagefright/ColorConverter.h
index 85ba920..7a18a85 100644
--- a/frameworks/av/include/media/stagefright/ColorConverter.h
+++ b/frameworks/av/include/media/stagefright/ColorConverter.h
@@ -72,7 +72,10 @@ private:
 
     status_t convertQCOMYUV420SemiPlanar(
             const BitmapParams &src, const BitmapParams &dst);
-
+#ifdef STE_HARDWARE
+    status_t convertSTEYUV420PackedSemiPlanarMB(
+            const BitmapParams &src, const BitmapParams &dst);
+#endif
     status_t convertYUV420SemiPlanar(
             const BitmapParams &src, const BitmapParams &dst);
 
diff --git a/frameworks/av/include/media/stagefright/FMRadioSource.h b/frameworks/av/include/media/stagefright/FMRadioSource.h
new file mode 100755
index 0000000..32db156
--- /dev/null
+++ b/frameworks/av/include/media/stagefright/FMRadioSource.h
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2012
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Author: Stefan Ekenberg (stefan.ekenberg@stericsson.com) for ST-Ericsson
+ */
+
+#ifndef FMRADIO_SOURCE_H_
+
+#define FMRADIO_SOURCE_H_
+
+#include <media/AudioRecord.h>
+#include <media/stagefright/DataSource.h>
+#include <media/stagefright/foundation/ABase.h>
+#include <system/audio.h>
+
+namespace android {
+
+class FMRadioSource : public DataSource {
+public:
+    FMRadioSource();
+
+    virtual status_t initCheck() const;
+    virtual ssize_t readAt(off64_t offset, void *data, size_t size);
+    virtual status_t getSize(off64_t *size);
+
+protected:
+    virtual ~FMRadioSource();
+
+private:
+    struct Buffer {
+        size_t  frameCount;
+        size_t  size;
+        int8_t* data;
+    };
+
+    status_t openRecord(int frameCount, audio_io_handle_t input);
+    status_t obtainBuffer(Buffer* audioBuffer);
+
+    status_t mInitCheck;
+    bool mStarted;
+    int mSessionId;
+    sp<IAudioRecord> mAudioRecord;
+    sp<IMemory> mCblkMemory;
+    audio_track_cblk_t* mCblk;
+
+    DISALLOW_EVIL_CONSTRUCTORS(FMRadioSource);
+};
+
+}  // namespace android
+
+#endif  // FMRADIO_SOURCE_H_
diff --git a/frameworks/av/include/media/stagefright/MediaDefs.h b/frameworks/av/include/media/stagefright/MediaDefs.h
index 457d5d7..d1977b5 100644
--- a/frameworks/av/include/media/stagefright/MediaDefs.h
+++ b/frameworks/av/include/media/stagefright/MediaDefs.h
@@ -26,8 +26,14 @@ extern const char *MEDIA_MIMETYPE_VIDEO_VPX;
 extern const char *MEDIA_MIMETYPE_VIDEO_AVC;
 extern const char *MEDIA_MIMETYPE_VIDEO_MPEG4;
 extern const char *MEDIA_MIMETYPE_VIDEO_H263;
+#ifdef STE_HARDWARE
+extern const char *MEDIA_MIMETYPE_VIDEO_H263_SW;
+#endif
 extern const char *MEDIA_MIMETYPE_VIDEO_MPEG2;
 extern const char *MEDIA_MIMETYPE_VIDEO_RAW;
+#ifdef STE_HARDWARE
+extern const char *MEDIA_MIMETYPE_VIDEO_VC1;
+#endif
 
 extern const char *MEDIA_MIMETYPE_AUDIO_AMR_NB;
 extern const char *MEDIA_MIMETYPE_AUDIO_AMR_WB;
diff --git a/frameworks/av/include/media/stagefright/OMXCodec.h b/frameworks/av/include/media/stagefright/OMXCodec.h
index 81350ca..a605411 100644
--- a/frameworks/av/include/media/stagefright/OMXCodec.h
+++ b/frameworks/av/include/media/stagefright/OMXCodec.h
@@ -85,7 +85,9 @@ struct OMXCodec : public MediaSource,
 
     // from MediaBufferObserver
     virtual void signalBufferReturned(MediaBuffer *buffer);
-
+#ifdef STE_HARDWARE
+    static uint32_t OmxToHALFormat(OMX_COLOR_FORMATTYPE omxValue);
+#endif
     enum Quirks {
         kNeedsFlushBeforeDisable              = 1,
         kWantsNALFragments                    = 2,
@@ -101,6 +103,9 @@ struct OMXCodec : public MediaSource,
         kAvoidMemcopyInputRecordingFrames     = 2048,
         kRequiresLargerEncoderOutputBuffer    = 4096,
         kOutputBuffersAreUnreadable           = 8192,
+#ifdef STE_HARDWARE
+        kRequiresStoreMetaDataBeforeIdle      = 16384,
+#endif
     };
 
     // for use by ACodec
@@ -352,7 +357,10 @@ private:
     status_t parseAVCCodecSpecificData(
             const void *data, size_t size,
             unsigned *profile, unsigned *level);
-
+#ifdef STE_HARDWARE
+    status_t parseVC1CodecSpecificData(
+            const void *data, size_t size);
+#endif
     OMXCodec(const OMXCodec &);
     OMXCodec &operator=(const OMXCodec &);
 };
diff --git a/frameworks/av/media/libstagefright/ACodec.cpp b/frameworks/av/media/libstagefright/ACodec.cpp
index c4743a1..12a512e 100644
--- a/frameworks/av/media/libstagefright/ACodec.cpp
+++ b/frameworks/av/media/libstagefright/ACodec.cpp
@@ -503,8 +503,11 @@ status_t ACodec::allocateOutputBuffersFromNativeWindow() {
             mNativeWindow.get(),
             def.format.video.nFrameWidth,
             def.format.video.nFrameHeight,
+#ifdef STE_HARDWARE		
+			OMXCodec::OmxToHALFormat(def.format.video.eColorFormat));
+#else
             def.format.video.eColorFormat);
-
+#endif
     if (err != 0) {
         ALOGE("native_window_set_buffers_geometry failed: %s (%d)",
                 strerror(-err), -err);
@@ -1357,6 +1360,9 @@ status_t ACodec::setSupportedOutputFormat() {
            || format.eColorFormat == OMX_COLOR_FormatYUV420SemiPlanar
            || format.eColorFormat == OMX_COLOR_FormatCbYCrY
            || format.eColorFormat == OMX_TI_COLOR_FormatYUV420PackedSemiPlanar
+#ifdef STE_HARDWARE	
+           || format.eColorFormat == OMX_STE_COLOR_FormatYUV420PackedSemiPlanarMB
+#endif
            || format.eColorFormat == OMX_QCOM_COLOR_FormatYVU420SemiPlanar);
 
     return mOMX->setParameter(
diff --git a/frameworks/av/media/libstagefright/Android.mk b/frameworks/av/media/libstagefright/Android.mk
index 8ad1cb9..5567de5 100644
--- a/frameworks/av/media/libstagefright/Android.mk
+++ b/frameworks/av/media/libstagefright/Android.mk
@@ -54,6 +54,11 @@ LOCAL_SRC_FILES:=                         \
         XINGSeeker.cpp                    \
         avc_utils.cpp                     \
 
+ifeq ($(BOARD_USES_STE_FM),true)
+LOCAL_SRC_FILES+=                         \
+        FMRadioSource.cpp                 \
+        PCMExtractor.cpp
+endif
 LOCAL_C_INCLUDES:= \
         $(TOP)/frameworks/av/include/media/stagefright/timedtext \
         $(TOP)/frameworks/native/include/media/hardware \
diff --git a/frameworks/av/media/libstagefright/AwesomePlayer.cpp b/frameworks/av/media/libstagefright/AwesomePlayer.cpp
index 0f346d8..9bab673 100644
--- a/frameworks/av/media/libstagefright/AwesomePlayer.cpp
+++ b/frameworks/av/media/libstagefright/AwesomePlayer.cpp
@@ -41,6 +41,7 @@
 #include <media/stagefright/AudioPlayer.h>
 #include <media/stagefright/DataSource.h>
 #include <media/stagefright/FileSource.h>
+#include <media/stagefright/FMRadioSource.h>
 #include <media/stagefright/MediaBuffer.h>
 #include <media/stagefright/MediaDefs.h>
 #include <media/stagefright/MediaExtractor.h>
@@ -2106,6 +2107,15 @@ status_t AwesomePlayer::finishSetDataSource_l() {
                 return UNKNOWN_ERROR;
             }
         }
+#ifdef STE_FM
+    } else if (!strncasecmp("fmradio://rx", mUri.string(), 12)) {
+        sniffedMIME = MEDIA_MIMETYPE_AUDIO_RAW;
+        dataSource = new FMRadioSource();
+        status_t err = dataSource->initCheck();
+        if (err != OK) {
+            return err;
+        }
+#endif
     } else {
         dataSource = DataSource::CreateFromURI(mUri.string(), &mUriHeaders);
     }
diff --git a/frameworks/av/media/libstagefright/CameraSource.cpp b/frameworks/av/media/libstagefright/CameraSource.cpp
index 3ddad93..1ebc047 100755
--- a/frameworks/av/media/libstagefright/CameraSource.cpp
+++ b/frameworks/av/media/libstagefright/CameraSource.cpp
@@ -102,7 +102,11 @@ static int32_t getColorFormat(const char* colorFormat) {
     if (!strcmp(colorFormat, CameraParameters::PIXEL_FORMAT_YUV422I)) {
         return OMX_COLOR_FormatYCbYCr;
     }
-
+#ifdef STE_HARDWARE
+    if (!strcmp(colorFormat, CameraParameters::PIXEL_FORMAT_UYV422I)) {
+        return OMX_COLOR_FormatCbYCrY;
+    }
+#endif
     if (!strcmp(colorFormat, CameraParameters::PIXEL_FORMAT_RGB565)) {
        return OMX_COLOR_Format16bitRGB565;
     }
@@ -110,7 +114,11 @@ static int32_t getColorFormat(const char* colorFormat) {
     if (!strcmp(colorFormat, "OMX_TI_COLOR_FormatYUV420PackedSemiPlanar")) {
        return OMX_TI_COLOR_FormatYUV420PackedSemiPlanar;
     }
-
+#ifdef STE_HARDWARE
+    if (!strcmp(colorFormat, CameraParameters::PIXEL_FORMAT_YUV420MB)) {
+       return OMX_STE_COLOR_FormatYUV420PackedSemiPlanarMB;
+    }
+#endif
     ALOGE("Uknown color format (%s), please add it to "
          "CameraSource::getColorFormat", colorFormat);
 
@@ -539,13 +547,22 @@ status_t CameraSource::initWithCameraAccess(
 
     // XXX: query camera for the stride and slice height
     // when the capability becomes available.
+#ifdef STE_HARDWARE
+    int stride = newCameraParams.getInt(CameraParameters::KEY_RECORD_STRIDE);
+    int sliceHeight = newCameraParams.getInt(CameraParameters::KEY_RECORD_SLICE_HEIGHT);
+#endif
     mMeta = new MetaData;
     mMeta->setCString(kKeyMIMEType,  MEDIA_MIMETYPE_VIDEO_RAW);
     mMeta->setInt32(kKeyColorFormat, mColorFormat);
     mMeta->setInt32(kKeyWidth,       mVideoSize.width);
     mMeta->setInt32(kKeyHeight,      mVideoSize.height);
+#ifdef STE_HARDWARE
+    mMeta->setInt32(kKeyStride,      stride != -1 ? stride : mVideoSize.width);
+    mMeta->setInt32(kKeySliceHeight, sliceHeight != -1 ? sliceHeight : mVideoSize.height);
+#else
     mMeta->setInt32(kKeyStride,      mVideoSize.width);
     mMeta->setInt32(kKeySliceHeight, mVideoSize.height);
+#endif
     mMeta->setInt32(kKeyFrameRate,   mVideoFrameRate);
     return OK;
 }
diff --git a/frameworks/av/media/libstagefright/FMRadioSource.cpp b/frameworks/av/media/libstagefright/FMRadioSource.cpp
new file mode 100755
index 0000000..dea65e4
--- /dev/null
+++ b/frameworks/av/media/libstagefright/FMRadioSource.cpp
@@ -0,0 +1,206 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2012
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Author: Stefan Ekenberg (stefan.ekenberg@stericsson.com) for ST-Ericsson
+ */
+
+#define LOG_TAG "FMRadioSource"
+#include <utils/Log.h>
+
+#include <media/stagefright/FMRadioSource.h>
+#include <media/AudioSystem.h>
+#include <private/media/AudioTrackShared.h>
+#include <cutils/compiler.h>
+
+namespace android {
+
+static const int kSampleRate = 48000;
+static const audio_format_t kAudioFormat = AUDIO_FORMAT_PCM_16_BIT;
+static const uint32_t kChannelMask = AUDIO_CHANNEL_IN_STEREO;
+static const int kBufferTimeoutMs = 3000;
+
+FMRadioSource::FMRadioSource()
+    : mInitCheck(NO_INIT),
+      mStarted(false),
+      mSessionId(AudioSystem::newAudioSessionId()) {
+
+    // get FM Radio RX input
+    audio_in_acoustics_t flags = (audio_in_acoustics_t)
+                    (AUDIO_IN_ACOUSTICS_AGC_DISABLE |
+                     AUDIO_IN_ACOUSTICS_NS_DISABLE  |
+                     AUDIO_IN_ACOUSTICS_TX_DISABLE );
+
+    audio_io_handle_t input = AudioSystem::getInput(AUDIO_SOURCE_FM_RADIO_RX,
+                                                    kSampleRate,
+                                                    kAudioFormat,
+                                                    kChannelMask,
+                                                    (audio_in_acoustics_t)flags,
+                                                    mSessionId);
+    if (input == 0) {
+        ALOGE("Could not get audio input for FM Radio source");
+        mInitCheck = UNKNOWN_ERROR;
+        return;
+    }
+
+    // get frame count
+    int frameCount = 0;
+    status_t status = AudioRecord::getMinFrameCount(&frameCount, kSampleRate,
+                                                    kAudioFormat, popcount(kChannelMask));
+    if (status != NO_ERROR) {
+        mInitCheck = status;
+        return;
+    }
+
+    // create the IAudioRecord
+    status = openRecord(frameCount, input);
+    if (status != NO_ERROR) {
+        mInitCheck = status;
+        return;
+    }
+
+    AudioSystem::acquireAudioSessionId(mSessionId);
+
+    mInitCheck = OK;
+    return;
+}
+
+FMRadioSource::~FMRadioSource() {
+    AudioSystem::releaseAudioSessionId(mSessionId);
+}
+
+status_t FMRadioSource::initCheck() const {
+    return mInitCheck;
+}
+
+ssize_t FMRadioSource::readAt(off64_t offset, void *data, size_t size) {
+    Buffer audioBuffer;
+
+    if (!mStarted) {
+        status_t err = mAudioRecord->start(AudioSystem::SYNC_EVENT_NONE, 0);
+        if (err == OK) {
+            mStarted = true;
+        } else {
+            ALOGE("Failed to start audio source");
+            return 0;
+        }
+    }
+
+    // acquire a strong reference on the IAudioRecord and IMemory so that they cannot be destroyed
+    // while we are accessing the cblk
+    sp<IAudioRecord> audioRecord = mAudioRecord;
+    sp<IMemory> iMem = mCblkMemory;
+    audio_track_cblk_t* cblk = mCblk;
+
+    audioBuffer.frameCount = size / cblk->frameSize;
+
+    status_t err = obtainBuffer(&audioBuffer);
+    if (err != NO_ERROR) {
+        ALOGE("Error obtaining an audio buffer, giving up (err:%d).", err);
+        return 0;
+    }
+
+    memcpy(data, audioBuffer.data, audioBuffer.size);
+    mCblk->stepUser(audioBuffer.frameCount);
+
+    return audioBuffer.size;
+}
+
+status_t FMRadioSource::getSize(off64_t *size) {
+    *size = 0;
+    return OK;
+}
+
+// -------------------------------------------------------------------------
+
+status_t FMRadioSource::openRecord(int frameCount, audio_io_handle_t input)
+{
+    status_t status;
+    const sp<IAudioFlinger>& audioFlinger = AudioSystem::get_audio_flinger();
+    if (audioFlinger == 0) {
+        return NO_INIT;
+    }
+
+    sp<IAudioRecord> record = audioFlinger->openRecord(getpid(), input,
+                                                       kSampleRate,
+                                                       kAudioFormat,
+                                                       kChannelMask,
+                                                       frameCount,
+                                                       IAudioFlinger::TRACK_DEFAULT,
+                                                       &mSessionId,
+                                                       &status);
+
+    if (record == 0) {
+        ALOGE("AudioFlinger could not create record track, status: %d", status);
+        return status;
+    }
+
+    sp<IMemory> cblk = record->getCblk();
+    if (cblk == 0) {
+        ALOGE("Could not get control block");
+        return NO_INIT;
+    }
+    mAudioRecord = record;
+    mCblkMemory = cblk;
+    mCblk = static_cast<audio_track_cblk_t*>(cblk->pointer());
+    mCblk->buffers = (char*)mCblk + sizeof(audio_track_cblk_t);
+    android_atomic_and(~CBLK_DIRECTION_MSK, &mCblk->flags);
+    return NO_ERROR;
+}
+
+status_t FMRadioSource::obtainBuffer(Buffer* audioBuffer)
+{
+    status_t result = NO_ERROR;
+    uint32_t framesReq = audioBuffer->frameCount;
+
+    audioBuffer->frameCount = 0;
+    audioBuffer->size       = 0;
+
+    mCblk->lock.lock();
+    uint32_t framesReady = mCblk->framesReady();
+    if (framesReady == 0) {
+        do {
+            result = mCblk->cv.waitRelative(mCblk->lock, milliseconds(kBufferTimeoutMs));
+            if (CC_UNLIKELY(result != NO_ERROR)) {
+                ALOGE("obtainBuffer timed out (is the CPU pegged?) "
+                        "user=%08x, server=%08x", mCblk->user, mCblk->server);
+                mCblk->lock.unlock();
+                return TIMED_OUT;
+            }
+
+            framesReady = mCblk->framesReady();
+        } while (framesReady == 0);
+    }
+    mCblk->lock.unlock();
+
+    if (framesReq > framesReady) {
+        framesReq = framesReady;
+    }
+
+    uint32_t u = mCblk->user;
+    uint32_t bufferEnd = mCblk->userBase + mCblk->frameCount;
+
+    if (framesReq > bufferEnd - u) {
+        framesReq = bufferEnd - u;
+    }
+
+    audioBuffer->frameCount = framesReq;
+    audioBuffer->size       = framesReq * mCblk->frameSize;
+    audioBuffer->data       = (int8_t*)mCblk->buffer(u);
+
+    return NO_ERROR;
+}
+
+}  // namespace android
diff --git a/frameworks/av/media/libstagefright/MediaDefs.cpp b/frameworks/av/media/libstagefright/MediaDefs.cpp
index 2740d6b..26b83e8 100644
--- a/frameworks/av/media/libstagefright/MediaDefs.cpp
+++ b/frameworks/av/media/libstagefright/MediaDefs.cpp
@@ -24,9 +24,14 @@ const char *MEDIA_MIMETYPE_VIDEO_VPX = "video/x-vnd.on2.vp8";
 const char *MEDIA_MIMETYPE_VIDEO_AVC = "video/avc";
 const char *MEDIA_MIMETYPE_VIDEO_MPEG4 = "video/mp4v-es";
 const char *MEDIA_MIMETYPE_VIDEO_H263 = "video/3gpp";
+#ifdef STE_HARDWARE
+const char *MEDIA_MIMETYPE_VIDEO_H263_SW = "video/3gpp-sw";
+#endif
 const char *MEDIA_MIMETYPE_VIDEO_MPEG2 = "video/mpeg2";
 const char *MEDIA_MIMETYPE_VIDEO_RAW = "video/raw";
-
+#ifdef STE_HARDWARE
+const char *MEDIA_MIMETYPE_VIDEO_VC1 = "video/vc1";
+#endif
 const char *MEDIA_MIMETYPE_AUDIO_AMR_NB = "audio/3gpp";
 const char *MEDIA_MIMETYPE_AUDIO_AMR_WB = "audio/amr-wb";
 const char *MEDIA_MIMETYPE_AUDIO_MPEG = "audio/mpeg";
diff --git a/frameworks/av/media/libstagefright/MediaExtractor.cpp b/frameworks/av/media/libstagefright/MediaExtractor.cpp
index 9ab6611..a0c0b27 100644
--- a/frameworks/av/media/libstagefright/MediaExtractor.cpp
+++ b/frameworks/av/media/libstagefright/MediaExtractor.cpp
@@ -23,6 +23,7 @@
 #include "include/MPEG4Extractor.h"
 #include "include/WAVExtractor.h"
 #include "include/OggExtractor.h"
+#include "include/PCMExtractor.h"
 #include "include/MPEG2PSExtractor.h"
 #include "include/MPEG2TSExtractor.h"
 #include "include/DRMExtractor.h"
@@ -116,6 +117,10 @@ sp<MediaExtractor> MediaExtractor::Create(
         ret = new AACExtractor(source, meta);
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_MPEG2PS)) {
         ret = new MPEG2PSExtractor(source);
+#ifdef STE_FM
+    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_RAW)) {
+        ret = new PCMExtractor(source);
+#endif
     }
 
     if (ret != NULL) {
diff --git a/frameworks/av/media/libstagefright/OMXCodec.cpp b/frameworks/av/media/libstagefright/OMXCodec.cpp
index fde7ebf..00f59a8 100755
--- a/frameworks/av/media/libstagefright/OMXCodec.cpp
+++ b/frameworks/av/media/libstagefright/OMXCodec.cpp
@@ -233,7 +233,22 @@ void OMXCodec::findMatchingCodecs(
         matchingCodecs->sort(CompareSoftwareCodecsFirst);
     }
 }
-
+#ifdef STE_HARDWARE
+//static
+uint32_t OMXCodec::OmxToHALFormat(OMX_COLOR_FORMATTYPE omxValue) {
+    switch (omxValue) {
+        case OMX_STE_COLOR_FormatYUV420PackedSemiPlanarMB:
+            return HAL_PIXEL_FORMAT_YCBCR42XMBN;
+        case OMX_COLOR_FormatYUV420Planar:
+            return HAL_PIXEL_FORMAT_YCbCr_420_P;
+        case OMX_COLOR_FormatYUV420SemiPlanar:
+            return HAL_PIXEL_FORMAT_YCbCr_420_SP;
+        default:
+            ALOGI("Unknown OMX pixel format (0x%X), passing it on unchanged", omxValue);
+            return omxValue;
+    }
+}
+#endif
 // static
 uint32_t OMXCodec::getComponentQuirks(
         const MediaCodecList *list, size_t index) {
@@ -250,7 +265,13 @@ uint32_t OMXCodec::getComponentQuirks(
                 index, "output-buffers-are-unreadable")) {
         quirks |= kOutputBuffersAreUnreadable;
     }
-
+#ifdef STE_HARDWARE
+    if (list->codecHasQuirk(
+                index, "requires-store-metadata-before-idle")) {
+        quirks |= kRequiresStoreMetaDataBeforeIdle;
+        quirks |= kStoreMetaDataInVideoBuffers;
+    }
+#endif
     return quirks;
 }
 
@@ -454,7 +475,57 @@ status_t OMXCodec::parseAVCCodecSpecificData(
 
     return OK;
 }
+#ifdef STE_HARDWARE
+status_t OMXCodec::parseVC1CodecSpecificData(
+        const void *data, size_t size) {
+    static const uint32_t kVC1StartCode = 0x000001;
+    const uint8_t *ptr = (const uint8_t *)data;
+    uint32_t startCode = 0;
+
+    //************************************************************************************
+    // strf chunk of AVI stream has Sequence Header and Entry point Header which are     *
+    // specific to VC1-advanced profile stream                                           *
+    // --------------------------------------------------------------------------------- *
+    //                           'strf' Chunk                                            *
+    //         Sequence Header Start Code(SH)     --> 0x00 00 01 0f                      *
+    //         Entry Point Header Start Code(EPH) --> 0x00 00 01 0e                      *
+    // strf Chunk starts with 4 bytes of ChunkSize, 4 bytes of Width & 4 bytes of Height *
+    // followed by SH and EPH as shown below. Size of SH & EPH would not be part of      *
+    // stream data, needs to identify the same based on strf Chunk size                  *
+    // -----------------------------------------------------------------------           *
+    // |      |      |      |      |      |      |      |      |      |      |           *
+    // |  00  |  00  |  01  |  0f  |  xx  |  xx  |  xx  |  xx  |  xx  |  xx  |           *
+    // |      |      |      |      |      |      |      |      |      |      |           *
+    // -----------------------------------------------------------------------           *
+    // |      |      |      |      |      |      |      |      |      |      |           *
+    // |  00  |  00  |  01  |  0e  |  xx  |  xx  |  xx  |  xx  |  xx  |  xx  |           *
+    // |      |      |      |      |      |      |      |      |      |      |           *
+    // -----------------------------------------------------------------------           *
+    // minimum size should be less than 6 bytes as header is of 4 bytes                  *
+    // and atleast 1 byte of data. Checking for VC1 Start Code                           *
+    //***********************************************************************************/
+
+    startCode = (ptr[0] << 16) | (ptr[1] << 8) | ptr[2];
+    if (size < 6 || startCode != kVC1StartCode) {
+        return ERROR_MALFORMED;
+    }
 
+    // ReSync to the next start code to separate Sequence Header and Entry Point Header
+    uint32_t dataindex = 2;
+    uint32_t sizeOfSequenceHeader, sizeOfEntryPointHeader;
+    startCode = 0;
+    while (startCode != kVC1StartCode && dataindex < size) {
+        dataindex++;
+        startCode = (ptr[dataindex] << 16) | (ptr[dataindex + 1] << 8) |
+                ptr[dataindex + 2];
+    }
+    sizeOfSequenceHeader = dataindex;
+    addCodecSpecificData(ptr, sizeOfSequenceHeader);
+    sizeOfEntryPointHeader = size - dataindex;
+    addCodecSpecificData(ptr + dataindex, sizeOfEntryPointHeader);
+    return OK;
+}
+#endif
 status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
     ALOGV("configureCodec protected=%d",
          (mFlags & kEnableGrallocUsageProtected) ? 1 : 0);
@@ -704,6 +775,9 @@ static size_t getFrameSize(
         case OMX_COLOR_FormatYUV420Planar:
         case OMX_COLOR_FormatYUV420SemiPlanar:
         case OMX_TI_COLOR_FormatYUV420PackedSemiPlanar:
+#ifdef STE_HARDWARE
+        case OMX_STE_COLOR_FormatYUV420PackedSemiPlanarMB:
+#endif
         /*
         * FIXME: For the Opaque color format, the frame size does not
         * need to be (w*h*3)/2. It just needs to
@@ -1214,6 +1288,9 @@ status_t OMXCodec::setVideoOutputFormat(
                || format.eColorFormat == OMX_COLOR_FormatYUV420SemiPlanar
                || format.eColorFormat == OMX_COLOR_FormatCbYCrY
                || format.eColorFormat == OMX_TI_COLOR_FormatYUV420PackedSemiPlanar
+#ifdef STE_HARDWARE
+               || format.eColorFormat == OMX_STE_COLOR_FormatYUV420PackedSemiPlanarMB
+#endif
                || format.eColorFormat == OMX_QCOM_COLOR_FormatYVU420SemiPlanar);
 
         err = mOMX->setParameter(
@@ -1362,6 +1439,10 @@ void OMXCodec::setComponentRole(
             "video_decoder.h263", "video_encoder.h263" },
         { MEDIA_MIMETYPE_VIDEO_VPX,
             "video_decoder.vpx", "video_encoder.vpx" },
+#ifdef STE_HARDWARE
+        { MEDIA_MIMETYPE_VIDEO_VC1,
+            "video_decoder.vc1", "video_encoder.vc1" },
+#endif
         { MEDIA_MIMETYPE_AUDIO_RAW,
             "audio_decoder.raw", "audio_encoder.raw" },
         { MEDIA_MIMETYPE_AUDIO_FLAC,
@@ -1435,6 +1516,16 @@ status_t OMXCodec::init() {
     CHECK_EQ((int)mState, (int)LOADED);
 
     status_t err;
+#ifdef STE_HARDWARE
+    if ((mQuirks & kRequiresStoreMetaDataBeforeIdle)
+        && (mFlags & kStoreMetaDataInVideoBuffers)) {
+        err = mOMX->storeMetaDataInBuffers(mNode, kPortIndexInput, OMX_TRUE);
+        if (err != OK) {
+            ALOGE("Storing meta data in video buffers is not supported");
+            return err;
+        }
+    }
+#endif
     if (!(mQuirks & kRequiresLoadedToIdleAfterAllocation)) {
         err = mOMX->sendCommand(mNode, OMX_CommandStateSet, OMX_StateIdle);
         CHECK_EQ(err, (status_t)OK);
@@ -1490,7 +1581,12 @@ status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
     }
 
     status_t err = OK;
+#ifdef STE_HARDWARE
+    if (!(mQuirks & kRequiresStoreMetaDataBeforeIdle)
+            && (mFlags & kStoreMetaDataInVideoBuffers)
+#else
     if ((mFlags & kStoreMetaDataInVideoBuffers)
+#endif
             && portIndex == kPortIndexInput) {
         err = mOMX->storeMetaDataInBuffers(mNode, kPortIndexInput, OMX_TRUE);
         if (err != OK) {
@@ -1686,8 +1782,11 @@ status_t OMXCodec::allocateOutputBuffersFromNativeWindow() {
             mNativeWindow.get(),
             def.format.video.nFrameWidth,
             def.format.video.nFrameHeight,
+#ifdef STE_HARDWARE	
+			OmxToHALFormat(def.format.video.eColorFormat));
+#else	
             def.format.video.eColorFormat);
-
+#endif
     if (err != 0) {
         ALOGE("native_window_set_buffers_geometry failed: %s (%d)",
                 strerror(-err), -err);
diff --git a/frameworks/av/media/libstagefright/PCMExtractor.cpp b/frameworks/av/media/libstagefright/PCMExtractor.cpp
new file mode 100755
index 0000000..bb26bcd
--- /dev/null
+++ b/frameworks/av/media/libstagefright/PCMExtractor.cpp
@@ -0,0 +1,302 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2010
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Author: Andreas Gustafsson (andreas.a.gustafsson@stericsson.com)
+ *         for ST-Ericsson
+ */
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "PCMExtractor"
+#include <utils/Log.h>
+
+#include "include/PCMExtractor.h"
+
+#include <media/stagefright/MediaBufferGroup.h>
+#include <media/stagefright/MediaDefs.h>
+#include <media/stagefright/MediaErrors.h>
+#include <media/stagefright/MetaData.h>
+#include <media/stagefright/foundation/ADebug.h>
+
+namespace android {
+
+/**
+* The default buffer size.
+*/
+static const uint16_t kDefaultNumChannels = 2;
+
+/**
+* The default Sample rate.
+*/
+static const uint32_t kDefaultSampleRate = 48000;
+
+/**
+* Bits per sample.
+*/
+static const uint16_t kDefaultBitsPerSample = 16;
+
+/**
+* The default buffer size.
+*/
+static const uint32_t kDefaultBufferSize = 4800;
+
+/**
+* Buffer duration in ms, to be used for input
+*/
+static const uint16_t kInputBufferDuration = 64;
+
+/**
+* Buffer granulairity in samples to be used for input.
+*/
+static const uint16_t kBufferGranularityInSamples = 16;
+
+struct PCMSource : public MediaSource {
+    PCMSource(
+            const sp<DataSource> &dataSource,
+            const sp<MetaData> &meta,
+            int32_t bitsPerSample,
+            off_t offset, size_t size);
+
+    virtual status_t start(MetaData *params = NULL);
+    virtual status_t stop();
+    virtual sp<MetaData> getFormat();
+
+    virtual status_t read(
+            MediaBuffer **buffer, const ReadOptions *options = NULL);
+
+protected:
+    virtual ~PCMSource();
+
+private:
+    static const size_t kMaxFrameSize;
+
+    sp<DataSource> mDataSource;
+    sp<MetaData> mMeta;
+    int32_t mSampleRate;
+    int32_t mNumChannels;
+    int32_t mBitsPerSample;
+    off_t mOffset;
+    size_t mSize;
+    bool mStarted;
+    MediaBufferGroup *mGroup;
+    off_t mCurrentPos;
+    uint32_t mBufferSize;
+
+    DISALLOW_EVIL_CONSTRUCTORS(PCMSource);
+};
+
+PCMExtractor::PCMExtractor(const sp<DataSource> &source)
+    : mDataSource(source),
+      mValidFormat(false) {
+    mInitCheck = init();
+}
+
+PCMExtractor::~PCMExtractor() {
+}
+
+sp<MetaData> PCMExtractor::getMetaData() {
+    sp<MetaData> meta = new MetaData;
+
+    if (mInitCheck != OK) {
+        return meta;
+    }
+
+    meta->setCString(kKeyMIMEType, "audio/raw");
+
+    return meta;
+}
+
+size_t PCMExtractor::countTracks() {
+    return mInitCheck == OK ? 1 : 0;
+}
+
+sp<MediaSource> PCMExtractor::getTrack(size_t index) {
+    if (mInitCheck != OK || index > 0) {
+        return NULL;
+    }
+
+    return new PCMSource(
+            mDataSource, mTrackMeta,
+            kDefaultBitsPerSample, mDataOffset, mDataSize);
+}
+
+sp<MetaData> PCMExtractor::getTrackMetaData(
+        size_t index, uint32_t flags) {
+    if (mInitCheck != OK || index > 0) {
+        return NULL;
+    }
+
+    return mTrackMeta;
+}
+
+status_t PCMExtractor::init() {
+    mDataOffset = 0;
+    mDataSize = 0;
+    mValidFormat = true;
+    mTrackMeta = new MetaData;mTrackMeta->setCString(kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_RAW);
+    mTrackMeta->setInt32(kKeyChannelCount, kDefaultNumChannels);
+    mTrackMeta->setInt32(kKeySampleRate, kDefaultSampleRate);
+    return OK;
+}
+
+const size_t PCMSource::kMaxFrameSize = 4800;
+
+PCMSource::PCMSource(
+        const sp<DataSource> &dataSource,
+        const sp<MetaData> &meta,
+        int32_t bitsPerSample,
+        off_t offset, size_t size)
+    : mDataSource(dataSource),
+      mMeta(meta),
+      mSampleRate(0),
+      mNumChannels(0),
+      mBitsPerSample(bitsPerSample),
+      mOffset(offset),
+      mSize(size),
+      mStarted(false),
+      mGroup(NULL),
+      mBufferSize(0) {
+    CHECK(mMeta->findInt32(kKeySampleRate, &mSampleRate));
+    CHECK(mMeta->findInt32(kKeyChannelCount, &mNumChannels));
+}
+
+PCMSource::~PCMSource() {
+    if (mStarted) {
+        stop();
+    }
+}
+
+status_t PCMSource::start(MetaData *params) {
+    CHECK(!mStarted);
+
+    size_t size = kDefaultBufferSize;
+
+    if (mSampleRate != 0 && mNumChannels != 0) {
+        mBufferSize = mSampleRate * kInputBufferDuration / 1000 * mNumChannels * 2;
+        size_t granularity = kBufferGranularityInSamples * 2 * mNumChannels;
+        mBufferSize = (mBufferSize / granularity) * granularity;
+    }
+    mGroup = new MediaBufferGroup;
+    mGroup->add_buffer(new MediaBuffer(mBufferSize));
+
+    if (mBitsPerSample == 8) {
+        // As a temporary buffer for 8->16 bit conversion.
+        mGroup->add_buffer(new MediaBuffer(mBufferSize));
+    }
+
+    mCurrentPos = mOffset;
+
+    mStarted = true;
+    return OK;
+}
+
+status_t PCMSource::stop() {
+
+    CHECK(mStarted);
+    delete mGroup;
+    mGroup = NULL;
+
+    mStarted = false;
+    return OK;
+}
+
+sp<MetaData> PCMSource::getFormat() {
+   return mMeta;
+}
+
+status_t PCMSource::read(
+        MediaBuffer **out, const ReadOptions *options) {
+    *out = NULL;
+    int64_t seekTimeUs;
+    ReadOptions::SeekMode seek = ReadOptions::SEEK_CLOSEST_SYNC;
+    if (options != NULL && options->getSeekTo(&seekTimeUs,&seek)) {
+        int64_t pos = (seekTimeUs * mSampleRate) / 1000000 * mNumChannels * 2;
+        if (pos > mSize) {
+            pos = mSize;
+        }
+        mCurrentPos = pos + mOffset;
+    }
+
+    MediaBuffer *buffer;
+    status_t err = mGroup->acquire_buffer(&buffer);
+    if (err != OK) {
+        return err;
+    }
+
+    ssize_t n = mDataSource->readAt(
+            mCurrentPos, buffer->data(), mBufferSize);
+    if (n <= 0) {
+        buffer->release();
+        buffer = NULL;
+        return ERROR_END_OF_STREAM;
+    }
+
+    mCurrentPos += n;
+
+    buffer->set_range(0, n);
+
+    if (mBitsPerSample == 8) {
+        // Convert 8-bit unsigned samples to 16-bit signed.
+
+        MediaBuffer *tmp;
+        CHECK_EQ(mGroup->acquire_buffer(&tmp), (status_t)OK);
+
+        // The new buffer holds the sample number of samples, but each
+        // one is 2 bytes wide.
+        tmp->set_range(0, 2 * n);
+
+        int16_t *dst = (int16_t *)tmp->data();
+        const uint8_t *src = (const uint8_t *)buffer->data();
+        while (n-- > 0) {
+            *dst++ = ((int16_t)(*src) - 128) * 256;
+            ++src;
+        }
+
+        buffer->release();
+        buffer = tmp;
+    } else if (mBitsPerSample == 24) {
+        // Convert 24-bit signed samples to 16-bit signed.
+
+        const uint8_t *src =
+            (const uint8_t *)buffer->data() + buffer->range_offset();
+        int16_t *dst = (int16_t *)src;
+
+        size_t numSamples = buffer->range_length() / 3;
+        for (size_t i = 0; i < numSamples; ++i) {
+            int32_t x = (int32_t)(src[0] | src[1] << 8 | src[2] << 16);
+            x = (x << 8) >> 8;  // sign extension
+
+            x = x >> 8;
+            *dst++ = (int16_t)x;
+            src += 3;
+        }
+
+        buffer->set_range(buffer->range_offset(), 2 * numSamples);
+    }
+
+    size_t bytesPerSample = mBitsPerSample >> 3;
+
+    buffer->meta_data()->setInt64(
+            kKeyTime,
+            1000000LL * (mCurrentPos - mOffset)
+                / (mNumChannels * bytesPerSample) / mSampleRate);
+
+
+    *out = buffer;
+
+    return OK;
+}
+
+}  // namespace android
diff --git a/frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp b/frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp
index 597167f..53ccc74 100644
--- a/frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp
+++ b/frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp
@@ -47,6 +47,9 @@ bool ColorConverter::isValid() const {
         case OMX_QCOM_COLOR_FormatYVU420SemiPlanar:
         case OMX_COLOR_FormatYUV420SemiPlanar:
         case OMX_TI_COLOR_FormatYUV420PackedSemiPlanar:
+#ifdef STE_HARDWARE
+        case OMX_STE_COLOR_FormatYUV420PackedSemiPlanarMB:
+#endif
             return true;
 
         default:
@@ -122,6 +125,11 @@ status_t ColorConverter::convert(
             err = convertTIYUV420PackedSemiPlanar(src, dst);
             break;
 
+#ifdef STE_HARDWARE
+        case OMX_STE_COLOR_FormatYUV420PackedSemiPlanarMB:
+            err = convertSTEYUV420PackedSemiPlanarMB(src, dst);
+            break;
+#endif
         default:
         {
             CHECK(!"Should not be here. Unknown color conversion.");
@@ -505,7 +513,144 @@ status_t ColorConverter::convertTIYUV420PackedSemiPlanar(
 
     return OK;
 }
+#ifdef STE_HARDWARE
+status_t ColorConverter::convertSTEYUV420PackedSemiPlanarMB(
+        const BitmapParams &src, const BitmapParams &dst) {
+
+    if (!((dst.mWidth & 1) == 0
+            && src.mCropLeft == 0
+            && src.mCropTop == 0
+            && src.cropWidth() == dst.cropWidth()
+            && src.cropHeight() == dst.cropHeight())) {
+        return ERROR_UNSUPPORTED;
+    }
+
+    OMX_U32 mx = src.mWidth / 16;
+    OMX_U32 my = src.mHeight / 16;
+    OMX_U32 lx, ly;
+    OMX_U32 *pChroma, *pLuma = (OMX_U32 *)src.mBits;
+
+    pChroma = (OMX_U32 *)src.mBits + mx * my * 64;
+    for (ly = 0; ly < my; ly++) {
+        for (lx = 0; lx < mx; lx++) {
+            OMX_U32 col, row, lumaWord, chromaWord1 = 0, rgbWord, i;
+            OMX_U8 y[4], cb[4], cr[4], r[4], g[4], b[4];
+            OMX_U32 *dstBuf, *locBuf;
+            OMX_U32 *pBurstLuma = 0, *pBurstChroma = 0;
+            OMX_U32 *pWordLuma = 0, *pWordChroma = 0;
+            OMX_U8 nbOfBlock;
+
+            dstBuf = ((OMX_U32 *)dst.mBits) + (ly * 16) * dst.mWidth / 2;
+            dstBuf += (lx * 16) / 2;
+
+            pBurstLuma = pLuma;
+            pBurstChroma = pChroma;
+
+            for (col = 0; col < 2; col++) {
+                // conversion of a macroblock
+                for (nbOfBlock = 0; nbOfBlock < 2; nbOfBlock++) {
+                    locBuf = dstBuf + 4 * col + 2 * nbOfBlock;
+                    OMX_U32 dstRowOrigo = ly * 16 * dst.mWidth;
+
+                    switch (nbOfBlock) {
+                    case 0:
+                        pWordLuma = pBurstLuma;
+                        pWordChroma = pBurstChroma;
+                        break;
+                    case 1:
+                        pWordLuma = pBurstLuma + 1;
+                        pWordChroma = pBurstChroma + 1;
+                        break;
+                    }
+                    for (row = 0; row < 16; row++) {
+
+                        // Check for cropping on the y axis
+                        if (ly * 16 + row >= dst.mHeight) {
+                            break;
+                        }
+
+                        lumaWord = *pWordLuma;
+                        pWordLuma += 2;
+                        if (row % 2 == 0) {
+                            chromaWord1 = *pWordChroma;
+                            pWordChroma += 2;
+                        }
+
+                        y[3] = ((lumaWord >> 24) & 0xff);
+                        y[2] = ((lumaWord >> 16) & 0xff);
+                        y[1] = ((lumaWord >>  8) & 0xff);
+                        y[0] = ((lumaWord >>  0) & 0xff);
+
+                        cb[0] = cb[1] = ((chromaWord1 >>  0) & 0xff);
+                        cb[2] = cb[3] = ((chromaWord1 >> 16) & 0xff);
+                        cr[0] = cr[1] = ((chromaWord1 >>  8) & 0xff);
+                        cr[2] = cr[3] = ((chromaWord1 >> 24) & 0xff);
+
+                        for (i = 0; i < 4; i++) {
+
+                            int32_t rW,gW,bW;
+
+                            rW = 298 * y[i] + 408 * cr[i] - 57059;
+                            gW = 298 * y[i] - 100 * cb[i] - 208 * cr[i] + 34713;
+                            bW = 298 * y[i] + 516 * cb[i] - 70887;
+
+                            if (rW < 0) {
+                                r[i] = 0;
+                            } else if (rW >= 65536) {
+                                r[i] = 255;
+                            } else {
+                                r[i] = (rW >> 8);
+                            }
+                            if (gW < 0) {
+                                g[i] = 0;
+                            } else if (gW >= 65536) {
+                                g[i] = 255;
+                            } else {
+                                g[i] = (gW >> 8);
+                            }
+                            if (bW < 0) {
+                                b[i] = 0;
+                            } else if (bW >= 65536) {
+                                b[i] = 255;
+                            } else {
+                                b[i] = (bW >> 8);
+                            }
+                            r[i] >>= 3;
+                            g[i] >>= 2;
+                            b[i] >>= 3;
+                        }
+                        for (i = 0; i < 4; i += 2) {
+
+                            // Check for cropping on the x axis
+                            OMX_U32 rowPos = (locBuf - (OMX_U32 *)dst.mBits) * 2 - dstRowOrigo;
+                            if (rowPos >= dst.mWidth) {
+                                locBuf++;
+                                continue;
+                            }
+
+                            rgbWord = (r[i + 1] << 27) +
+                                (g[i + 1] << 21) +
+                                (b[i + 1] << 16) +
+                                (r[i] << 11) +
+                                (g[i] << 5) +
+                                (b[i] << 0);
+                            *locBuf++ = rgbWord;
+                        }
+                        locBuf += dst.mWidth / 2 - 2;
+                        dstRowOrigo += dst.mWidth;
+                    } //end of for 16 loop
+                }  //end of 2 block loop
+                pBurstLuma += 32;
+                pBurstChroma += 16;
+            } // end of 2 col loop
+            pLuma   += 64;
+            pChroma += 32;
+        }
+    }
 
+    return OK;
+}
+#endif
 uint8_t *ColorConverter::initClip() {
     static const signed kClipMin = -278;
     static const signed kClipMax = 535;
diff --git a/frameworks/av/media/libstagefright/include/PCMExtractor.h b/frameworks/av/media/libstagefright/include/PCMExtractor.h
new file mode 100755
index 0000000..4717d10
--- /dev/null
+++ b/frameworks/av/media/libstagefright/include/PCMExtractor.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) ST-Ericsson SA 2010
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * Author: Andreas Gustafsson (andreas.a.gustafsson@stericsson.com)
+ *         for ST-Ericsson
+ */
+
+#ifndef PCM_EXTRACTOR_H_
+
+#define PCM_EXTRACTOR_H_
+
+#include <media/stagefright/DataSource.h>
+#include <media/stagefright/MediaSource.h>
+#include <media/stagefright/MediaExtractor.h>
+#include <media/stagefright/foundation/ABase.h>
+
+namespace android {
+
+class PCMExtractor : public MediaExtractor {
+public:
+    // Extractor assumes ownership of "source".
+    PCMExtractor(const sp<DataSource> &source);
+
+    virtual size_t countTracks();
+    virtual sp<MediaSource> getTrack(size_t index);
+    virtual sp<MetaData> getTrackMetaData(size_t index, uint32_t flags);
+
+    virtual sp<MetaData> getMetaData();
+
+protected:
+    virtual ~PCMExtractor();
+
+private:
+    sp<DataSource> mDataSource;
+    status_t mInitCheck;
+    bool mValidFormat;
+    off_t mDataOffset;
+    size_t mDataSize;
+    sp<MetaData> mTrackMeta;
+
+    status_t init();
+
+    DISALLOW_EVIL_CONSTRUCTORS(PCMExtractor);
+};
+
+}  // namespace android
+
+#endif  // PCM_EXTRACTOR_H_
diff --git a/frameworks/av/media/libstagefright/omx/SoftOMXPlugin.cpp b/frameworks/av/media/libstagefright/omx/SoftOMXPlugin.cpp
index 3747b3b..6d97973 100644
--- a/frameworks/av/media/libstagefright/omx/SoftOMXPlugin.cpp
+++ b/frameworks/av/media/libstagefright/omx/SoftOMXPlugin.cpp
@@ -34,7 +34,13 @@ static const struct {
     const char *mRole;
 
 } kComponents[] = {
+#ifdef STE_HARDWARE
+    { "OMX.ST.aac.decoder", "ste_aacdec", "audio_decoder.aac" },
+#endif
     { "OMX.google.aac.decoder", "aacdec", "audio_decoder.aac" },
+#ifdef STE_HARDWARE
+    { "OMX.google.aac.decoder", "aacdec", "audio_decoder.aeld" },
+#endif
     { "OMX.google.aac.encoder", "aacenc", "audio_encoder.aac" },
     { "OMX.google.amrnb.decoder", "amrdec", "audio_decoder.amrnb" },
     { "OMX.google.amrnb.encoder", "amrnbenc", "audio_encoder.amrnb" },
@@ -48,6 +54,9 @@ static const struct {
     { "OMX.google.h263.encoder", "mpeg4enc", "video_encoder.h263" },
     { "OMX.google.mpeg4.decoder", "mpeg4dec", "video_decoder.mpeg4" },
     { "OMX.google.mpeg4.encoder", "mpeg4enc", "video_encoder.mpeg4" },
+#ifdef STE_HARDWARE
+    { "OMX.ST.mp3.decoder", "ste_mp3dec", "audio_decoder.mp3" },
+#endif
     { "OMX.google.mp3.decoder", "mp3dec", "audio_decoder.mp3" },
     { "OMX.google.vorbis.decoder", "vorbisdec", "audio_decoder.vorbis" },
     { "OMX.google.vpx.decoder", "vpxdec", "video_decoder.vpx" },
