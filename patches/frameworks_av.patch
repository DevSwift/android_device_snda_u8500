#
#	modified:   frameworks/av/camera/CameraParameters.cpp
#	modified:   frameworks/av/include/camera/CameraParameters.h
#	modified:   frameworks/av/include/media/stagefright/OMXCodec.h
#	modified:   frameworks/av/media/libstagefright/CameraSource.cpp
#	modified:   frameworks/av/media/libstagefright/OMXCodec.cpp
#
diff --git a/frameworks/av/camera/CameraParameters.cpp b/frameworks/av/camera/CameraParameters.cpp
index 4114458..fe26a2e 100644
--- a/frameworks/av/camera/CameraParameters.cpp
+++ b/frameworks/av/camera/CameraParameters.cpp
@@ -278,6 +278,7 @@ const char CameraParameters::PIXEL_FORMAT_YUV420SP_ADRENO[] = "yuv420sp-adreno";
 #endif
 #ifdef STE_HARDWARE
 const char CameraParameters::PIXEL_FORMAT_YUV420SPNV12[] = "yuv420spnv12";
+const char CameraParameters::PIXEL_FORMAT_UYV422I[] = "yuv422i-uyvy";
 #endif
 const char CameraParameters::PIXEL_FORMAT_YUV422I[] = "yuv422i-yuyv";
 const char CameraParameters::PIXEL_FORMAT_YUV420P[]  = "yuv420p";
diff --git a/frameworks/av/include/camera/CameraParameters.h b/frameworks/av/include/camera/CameraParameters.h
index a871f0f..8d7322d 100644
--- a/frameworks/av/include/camera/CameraParameters.h
+++ b/frameworks/av/include/camera/CameraParameters.h
@@ -778,6 +778,7 @@ public:
 #endif
 #ifdef STE_HARDWARE
     static const char PIXEL_FORMAT_YUV420SPNV12[]; // NV12
+    static const char PIXEL_FORMAT_UYV422I[];
 #endif
     static const char PIXEL_FORMAT_YUV422I[]; // YUY2
     static const char PIXEL_FORMAT_YUV420P[]; // YV12
diff --git a/frameworks/av/include/media/stagefright/OMXCodec.h b/frameworks/av/include/media/stagefright/OMXCodec.h
index 09160fd..03b56b9 100644
--- a/frameworks/av/include/media/stagefright/OMXCodec.h
+++ b/frameworks/av/include/media/stagefright/OMXCodec.h
@@ -399,6 +399,10 @@ private:
 #ifdef QCOM_HARDWARE
     status_t flushBuffersOnError(void);
 #endif
+#ifdef STE_SNDA_HARDWARE
+    status_t parseVC1CodecSpecificData(
+            const void *data, size_t size);
+#endif
 
     OMXCodec(const OMXCodec &);
     OMXCodec &operator=(const OMXCodec &);
diff --git a/frameworks/av/media/libstagefright/CameraSource.cpp b/frameworks/av/media/libstagefright/CameraSource.cpp
index 30ddee7..c4141b3 100755
--- a/frameworks/av/media/libstagefright/CameraSource.cpp
+++ b/frameworks/av/media/libstagefright/CameraSource.cpp
@@ -116,7 +116,11 @@ static int32_t getColorFormat(const char* colorFormat) {
         return OMX_COLOR_FormatYCbYCr;
 #endif
     }
-
+#ifdef STE_SNDA_HARDWARE
+    if (!strcmp(colorFormat, CameraParameters::PIXEL_FORMAT_UYV422I)) {
+        return OMX_COLOR_FormatCbYCrY;
+    }
+#endif
     if (!strcmp(colorFormat, CameraParameters::PIXEL_FORMAT_RGB565)) {
        return OMX_COLOR_Format16bitRGB565;
     }
diff --git a/frameworks/av/media/libstagefright/OMXCodec.cpp b/frameworks/av/media/libstagefright/OMXCodec.cpp
index 0264725..6ea5b66 100644
--- a/frameworks/av/media/libstagefright/OMXCodec.cpp
+++ b/frameworks/av/media/libstagefright/OMXCodec.cpp
@@ -275,6 +275,10 @@ uint32_t OMXCodec::OmxToHALFormat(OMX_COLOR_FORMATTYPE omxValue) {
             return HAL_PIXEL_FORMAT_YCBCR42XMBN;
         case OMX_COLOR_FormatYUV420Planar:
             return HAL_PIXEL_FORMAT_YCbCr_420_P;
+#ifdef STE_SNDA_HARDWARE
+        case OMX_COLOR_FormatYUV420SemiPlanar:
+            return HAL_PIXEL_FORMAT_YCbCr_420_SP;
+#endif
         default:
             ALOGI("Unknown OMX pixel format (0x%X), passing it on unchanged", omxValue);
             return omxValue;
@@ -318,6 +322,9 @@ uint32_t OMXCodec::getComponentQuirks(
     if (list->codecHasQuirk(
                 index, "requires-store-metadata-before-idle")) {
       quirks |= kRequiresStoreMetaDataBeforeIdle;
+#ifdef STE_SNDA_HARDWARE
+      quirks |= kStoreMetaDataInVideoBuffers;
+#endif
     }
 #endif
 #ifdef QCOM_HARDWARE
@@ -589,7 +596,57 @@ status_t OMXCodec::parseAVCCodecSpecificData(
 
     return OK;
 }
+#ifdef STE_SNDA_HARDWARE
+status_t OMXCodec::parseVC1CodecSpecificData(
+        const void *data, size_t size) {
+    static const uint32_t kVC1StartCode = 0x000001;
+    const uint8_t *ptr = (const uint8_t *)data;
+    uint32_t startCode = 0;
+
+    //************************************************************************************
+    // strf chunk of AVI stream has Sequence Header and Entry point Header which are     *
+    // specific to VC1-advanced profile stream                                           *
+    // --------------------------------------------------------------------------------- *
+    //                           'strf' Chunk                                            *
+    //         Sequence Header Start Code(SH)     --> 0x00 00 01 0f                      *
+    //         Entry Point Header Start Code(EPH) --> 0x00 00 01 0e                      *
+    // strf Chunk starts with 4 bytes of ChunkSize, 4 bytes of Width & 4 bytes of Height *
+    // followed by SH and EPH as shown below. Size of SH & EPH would not be part of      *
+    // stream data, needs to identify the same based on strf Chunk size                  *
+    // -----------------------------------------------------------------------           *
+    // |      |      |      |      |      |      |      |      |      |      |           *
+    // |  00  |  00  |  01  |  0f  |  xx  |  xx  |  xx  |  xx  |  xx  |  xx  |           *
+    // |      |      |      |      |      |      |      |      |      |      |           *
+    // -----------------------------------------------------------------------           *
+    // |      |      |      |      |      |      |      |      |      |      |           *
+    // |  00  |  00  |  01  |  0e  |  xx  |  xx  |  xx  |  xx  |  xx  |  xx  |           *
+    // |      |      |      |      |      |      |      |      |      |      |           *
+    // -----------------------------------------------------------------------           *
+    // minimum size should be less than 6 bytes as header is of 4 bytes                  *
+    // and atleast 1 byte of data. Checking for VC1 Start Code                           *
+    //***********************************************************************************/
+
+    startCode = (ptr[0] << 16) | (ptr[1] << 8) | ptr[2];
+    if (size < 6 || startCode != kVC1StartCode) {
+        return ERROR_MALFORMED;
+    }
 
+    // ReSync to the next start code to separate Sequence Header and Entry Point Header
+    uint32_t dataindex = 2;
+    uint32_t sizeOfSequenceHeader, sizeOfEntryPointHeader;
+    startCode = 0;
+    while (startCode != kVC1StartCode && dataindex < size) {
+        dataindex++;
+        startCode = (ptr[dataindex] << 16) | (ptr[dataindex + 1] << 8) |
+                ptr[dataindex + 2];
+    }
+    sizeOfSequenceHeader = dataindex;
+    addCodecSpecificData(ptr, sizeOfSequenceHeader);
+    sizeOfEntryPointHeader = size - dataindex;
+    addCodecSpecificData(ptr + dataindex, sizeOfEntryPointHeader);
+    return OK;
+}
+#endif
 status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
     ALOGV("configureCodec protected=%d",
          (mFlags & kEnableGrallocUsageProtected) ? 1 : 0);
