#
#	modified:   system/vold/Android.mk
#	modified:   system/vold/DirectVolume.cpp
#	modified:   system/vold/DirectVolume.h
#	modified:   system/vold/Fat.cpp
#	modified:   system/vold/Fat.h
#	modified:   system/vold/Volume.cpp
#	modified:   system/vold/Volume.h
#	modified:   system/vold/VolumeManager.cpp
#	modified:   system/vold/VolumeManager.h
#
diff --git a/system/vold/Android.mk b/system/vold/Android.mk
index b7a4905..3538805 100644
--- a/system/vold/Android.mk
+++ b/system/vold/Android.mk
@@ -44,6 +44,10 @@ LOCAL_STATIC_LIBRARIES := libfs_mgr
 
 LOCAL_MODULE_TAGS := eng tests
 
+ifeq ($(BOARD_USES_STE_HARDWARE),true)
+	LOCAL_CFLAGS += -DSTE_HARDWARE
+endif
+
 include $(BUILD_STATIC_LIBRARY)
 
 include $(CLEAR_VARS)
diff --git a/system/vold/DirectVolume.cpp b/system/vold/DirectVolume.cpp
index 4acee76..3e35f45 100644
--- a/system/vold/DirectVolume.cpp
+++ b/system/vold/DirectVolume.cpp
@@ -271,6 +271,7 @@ void DirectVolume::handlePartitionChanged(const char *devpath, NetlinkEvent *evt
     SLOGD("Volume %s %s partition %d:%d changed\n", getLabel(), getMountpoint(), major, minor);
 }
 
+#ifndef STE_HARDWARE
 void DirectVolume::handleDiskRemoved(const char *devpath, NetlinkEvent *evt) {
     int major = atoi(evt->findParam("MAJOR"));
     int minor = atoi(evt->findParam("MINOR"));
@@ -292,6 +293,11 @@ void DirectVolume::handlePartitionRemoved(const char *devpath, NetlinkEvent *evt
 
     SLOGD("Volume %s %s partition %d:%d removed\n", getLabel(), getMountpoint(), major, minor);
 
+#else
+int DirectVolume::doUnmountLostMedia(int major, int minor) {
+    char msg[255];
+    int state;
+#endif
     /*
      * The framework doesn't need to get notified of
      * partition removal unless it's mounted. Otherwise
@@ -300,7 +306,11 @@ void DirectVolume::handlePartitionRemoved(const char *devpath, NetlinkEvent *evt
      */
     state = getState();
     if (state != Volume::State_Mounted && state != Volume::State_Shared) {
+#ifndef STE_HARDWARE
         return;
+#else
+        return 0;
+#endif
     }
         
     if ((dev_t) MKDEV(major, minor) == mCurrentlyMountedKdev) {
@@ -321,6 +331,9 @@ void DirectVolume::handlePartitionRemoved(const char *devpath, NetlinkEvent *evt
             SLOGE("Failed to unmount volume on bad removal (%s)", 
                  strerror(errno));
             // XXX: At this point we're screwed for now
+#ifdef STE_HARDWARE
+            return -1;
+#endif
         } else {
             SLOGD("Crisis averted");
         }
@@ -338,6 +351,42 @@ void DirectVolume::handlePartitionRemoved(const char *devpath, NetlinkEvent *evt
             SLOGD("Crisis averted");
         }
     }
+#ifdef STE_HARDWARE
+    return 0;
+}
+
+
+void DirectVolume::handleDiskRemoved(const char *devpath, NetlinkEvent *evt) {
+    char msg[255];
+    int major = atoi(evt->findParam("MAJOR"));
+    int minor = atoi(evt->findParam("MINOR"));
+
+    SLOGD("Volume %s %s disk %d:%d removed\n", getLabel(), getMountpoint(), major, minor);
+
+    if (getState() == Volume::State_Mounted) {
+         SLOGW("Volume mounted when device was removed, unmounting...\n");
+         if (doUnmountLostMedia(major, minor))
+	     SLOGE("Failed to unmount file systems from removed disk\n");
+    }
+
+    snprintf(msg, sizeof(msg), "Volume %s %s disk removed (%d:%d)",
+             getLabel(), getMountpoint(), major, minor);
+
+    mVm->getBroadcaster()->sendBroadcast(ResponseCode::VolumeDiskRemoved,
+                                             msg, false);
+    setState(Volume::State_NoMedia);
+}
+
+void DirectVolume::handlePartitionRemoved(const char *devpath, NetlinkEvent *evt) {
+    int major = atoi(evt->findParam("MAJOR"));
+    int minor = atoi(evt->findParam("MINOR"));
+    char msg[255];
+
+    SLOGD("Volume %s %s partition %d:%d removed\n", getLabel(), getMountpoint(), major, minor);
+
+    if (doUnmountLostMedia(major, minor))
+	SLOGE("Failed to unmount file systems from detached partition\n");
+#endif
 }
 
 /*
diff --git a/system/vold/DirectVolume.h b/system/vold/DirectVolume.h
index de1ed8b..1e7ea41 100644
--- a/system/vold/DirectVolume.h
+++ b/system/vold/DirectVolume.h
@@ -21,13 +21,11 @@
 
 #include "Volume.h"
 
-#define MAX_PARTS 4
-
 typedef android::List<char *> PathCollection;
 
 class DirectVolume : public Volume {
 public:
-    static const int MAX_PARTITIONS = 4;
+    static const int MAX_PARTITIONS = MAX_PARTS;
 protected:
     PathCollection *mPaths;
     int            mDiskMajor;
@@ -72,6 +70,7 @@ private:
 
     int doMountVfat(const char *deviceNode, const char *mountPoint);
 
+    int doUnmountLostMedia(int major, int minor);
 };
 
 typedef android::List<DirectVolume *> DirectVolumeCollection;
diff --git a/system/vold/Fat.cpp b/system/vold/Fat.cpp
index 82a3f7a..08b87a7 100644
--- a/system/vold/Fat.cpp
+++ b/system/vold/Fat.cpp
@@ -42,6 +42,12 @@
 
 static char FSCK_MSDOS_PATH[] = "/system/bin/fsck_msdos";
 static char MKDOSFS_PATH[] = "/system/bin/newfs_msdos";
+#ifdef STE_HARDWARE
+static const long SECTORS_8MB = 16384;
+static const long SECTORS_32MB = 65536;
+static const long SECTORS_1GB = 2097152;
+static const long SECTORS_2GB = 4194304;
+#endif
 extern "C" int logwrap(int argc, const char **argv, int background);
 extern "C" int mount(const char *, const char *, const char *, unsigned long, const void *);
 
@@ -150,7 +156,7 @@ int Fat::doMount(const char *fsPath, const char *mountPoint,
 
     return rc;
 }
-
+#ifndef STE_HARDWARE
 int Fat::format(const char *fsPath, unsigned int numSectors) {
     int fd;
     const char *args[11];
@@ -178,7 +184,41 @@ int Fat::format(const char *fsPath, unsigned int numSectors) {
         args[8] = NULL;
         rc = logwrap(9, args, 1);
     }
+#else
+int Fat::format(const char *fsPath, long numSectors) {
+    int fd;
+    const char *args[11];
+    int rc;
+
+    args[0] = MKDOSFS_PATH;
+    args[1] = "-O";
+    args[2] = "android";
+    args[3] = "-F";
+
+    /*
+     * Pick FAT bits and sectors/cluster reasonably
+     * in line with SD card spec
+     */
+    if (numSectors <= SECTORS_32MB)
+        args[4] = "12";
+    else if (numSectors < SECTORS_2GB)
+        args[4] = "16";
+    else
+        args[4] = "32";
+
+    args[5] = "-c";
 
+    if (numSectors <= SECTORS_8MB)
+        args[6] = "16";
+    else if (numSectors <= SECTORS_1GB)
+        args[6] = "32";
+    else
+        args[6] = "64";
+
+    args[7] = fsPath;
+    args[8] = NULL;
+    rc = logwrap(9, args, 1);
+#endif
     if (rc == 0) {
         SLOGI("Filesystem formatted OK");
         return 0;
diff --git a/system/vold/Fat.h b/system/vold/Fat.h
index e02d88c..0459376 100644
--- a/system/vold/Fat.h
+++ b/system/vold/Fat.h
@@ -26,7 +26,11 @@ public:
                        bool ro, bool remount, bool executable,
                        int ownerUid, int ownerGid, int permMask,
                        bool createLost);
+#ifndef STE_HARDWARE
     static int format(const char *fsPath, unsigned int numSectors);
+#else
+    static int format(const char *fsPath, long numSectors);
+#endif
 };
 
 #endif
diff --git a/system/vold/Volume.cpp b/system/vold/Volume.cpp
index a71000e..0ce7be6 100644
--- a/system/vold/Volume.cpp
+++ b/system/vold/Volume.cpp
@@ -46,7 +46,10 @@
 #include "Fat.h"
 #include "Process.h"
 #include "cryptfs.h"
-
+#ifdef STE_HARDWARE
+static const long SECTORS_2GB = 4194304;
+static const long SECTORS_32GB = 67108864;
+#endif
 extern "C" void dos_partition_dec(void const *pp, struct dos_partition *d);
 extern "C" void dos_partition_enc(void *pp, struct dos_partition *d);
 
@@ -228,8 +231,12 @@ int Volume::formatVol() {
     bool formatEntireDevice = (mPartIdx == -1);
     char devicePath[255];
     dev_t diskNode = getDiskDevice();
+#ifndef STE_HARDWARE
     dev_t partNode = MKDEV(MAJOR(diskNode), (formatEntireDevice ? 1 : mPartIdx));
-
+#else
+    dev_t partNode = MKDEV(MAJOR(diskNode), (formatEntireDevice ? MINOR(diskNode) + 1 : mPartIdx));
+    long numSectors;
+#endif
     setState(Volume::State_Formatting);
 
     int ret = -1;
@@ -237,8 +244,16 @@ int Volume::formatVol() {
     if (formatEntireDevice) {
         sprintf(devicePath, "/dev/block/vold/%d:%d",
                 MAJOR(diskNode), MINOR(diskNode));
+#ifdef STE_HARDWARE
+        if (getSectorCount(devicePath, &numSectors)) {
+            SLOGE("Failed to retrieve device size (%s)", strerror(errno));
+            goto err;
+        }
 
+        if (initializeMbr(devicePath, numSectors)) {
+#else
         if (initializeMbr(devicePath)) {
+#endif
             SLOGE("Failed to initialize MBR (%s)", strerror(errno));
             goto err;
         }
@@ -250,8 +265,16 @@ int Volume::formatVol() {
     if (mDebug) {
         SLOGI("Formatting volume %s (%s)", getLabel(), devicePath);
     }
+#ifdef STE_HARDWARE
+    if (getSectorCount(devicePath, &numSectors)) {
+        SLOGE("Failed to retrieve device size (%s)", strerror(errno));
+        goto err;
+    }
 
+    if (Fat::format(devicePath, numSectors)) {
+#else
     if (Fat::format(devicePath, 0)) {
+#endif
         SLOGE("Failed to format (%s)", strerror(errno));
         goto err;
     }
@@ -290,7 +313,7 @@ bool Volume::isMountpointMounted(const char *path) {
 }
 
 int Volume::mountVol() {
-    dev_t deviceNodes[4];
+    dev_t deviceNodes[MAX_PARTS];
     int n, i, rc = 0;
     char errmsg[255];
     const char* externalStorage = getenv("EXTERNAL_STORAGE");
@@ -331,7 +354,7 @@ int Volume::mountVol() {
         return 0;
     }
 
-    n = getDeviceNodes((dev_t *) &deviceNodes, 4);
+    n = getDeviceNodes((dev_t *) &deviceNodes, MAX_PARTS);
     if (!n) {
         SLOGE("Failed to get device nodes (%s)\n", strerror(errno));
         return -1;
@@ -380,7 +403,7 @@ int Volume::mountVol() {
         updateDeviceInfo(nodepath, new_major, new_minor);
 
         /* Get the device nodes again, because they just changed */
-        n = getDeviceNodes((dev_t *) &deviceNodes, 4);
+        n = getDeviceNodes((dev_t *) &deviceNodes, MAX_PARTS);
         if (!n) {
             SLOGE("Failed to get device nodes (%s)\n", strerror(errno));
             return -1;
@@ -689,7 +712,41 @@ out_nomedia:
     setState(Volume::State_NoMedia);
     return -1;
 }
+#ifdef STE_HARDWARE
+int Volume::getSectorCount(const char *deviceNode, long *numSectors) {
+    int fd;
+
+    fd = open(deviceNode, O_RDONLY);
+    if (fd < 0) {
+        SLOGE("Failed to open device (%s)", strerror(errno));
+        return -1;
+    }
+
+    /*
+     * Ask the device how many 512 byte blocks (sectors) it contains
+     */
+    if (ioctl(fd, BLKGETSIZE, numSectors)) {
+        SLOGE("Failed to get block count (%s)", strerror(errno));
+        if (close(fd)) {
+            SLOGE("Failed to close device (%s)", strerror(errno));
+        }
+        return -1;
+    }
+
+    if (close(fd))
+    {
+        SLOGE("Failed to close device (%s)", strerror(errno));
+        return -1;
+    }
+
+    return 0;
+}
+#endif
+#ifdef STE_HARDWARE
+int Volume::initializeMbr(const char *deviceNode, long numSectors) {
+#else
 int Volume::initializeMbr(const char *deviceNode) {
+#endif
     struct disk_info dinfo;
 
     memset(&dinfo, 0, sizeof(dinfo));
@@ -703,7 +760,20 @@ int Volume::initializeMbr(const char *deviceNode) {
     dinfo.device = strdup(deviceNode);
     dinfo.scheme = PART_SCHEME_MBR;
     dinfo.sect_size = 512;
+#ifndef STE_HARDWARE
     dinfo.skip_lba = 2048;
+#else
+    /*
+     * Set partition start reasonably in line
+     * with SD card spec
+     */
+    if (numSectors <= SECTORS_2GB)
+        dinfo.skip_lba = 128;
+    else if (numSectors <= SECTORS_32GB)
+        dinfo.skip_lba = 8192;
+    else
+        dinfo.skip_lba = 32768;
+#endif
     dinfo.num_lba = 0;
     dinfo.num_parts = 1;
 
diff --git a/system/vold/Volume.h b/system/vold/Volume.h
index c717d4d..cfc5510 100644
--- a/system/vold/Volume.h
+++ b/system/vold/Volume.h
@@ -19,6 +19,8 @@
 
 #include <utils/List.h>
 
+#define MAX_PARTS 8
+
 class NetlinkEvent;
 class VolumeManager;
 
@@ -94,7 +96,12 @@ protected:
     int createDeviceNode(const char *path, int major, int minor);
 
 private:
+#ifndef STE_HARDWARE
     int initializeMbr(const char *deviceNode);
+#else
+    int initializeMbr(const char *deviceNode, long numSectors);
+    int getSectorCount(const char *deviceNode, long *numSectors);
+#endif
     bool isMountpointMounted(const char *path);
     int createBindMounts();
     int doUnmount(const char *path, bool force);
diff --git a/system/vold/VolumeManager.cpp b/system/vold/VolumeManager.cpp
index 0388010..b04e57f 100644
--- a/system/vold/VolumeManager.cpp
+++ b/system/vold/VolumeManager.cpp
@@ -984,7 +984,7 @@ int VolumeManager::mountAsec(const char *id, const char *key, int ownerUid) {
     }
     return 0;
 }
-
+#ifndef STE_HARDWARE
 Volume* VolumeManager::getVolumeForFile(const char *fileName) {
     VolumeCollection::iterator i;
 
@@ -997,7 +997,7 @@ Volume* VolumeManager::getVolumeForFile(const char *fileName) {
 
     return NULL;
 }
-
+#endif
 /**
  * Mounts an image file <code>img</code>.
  */
@@ -1126,7 +1126,11 @@ int VolumeManager::listMountedObbs(SocketClient* cli) {
     }
 
     // Create a string to compare against that has a trailing slash
+#ifdef STE_HARDWARE
     int loopDirLen = strlen(Volume::LOOPDIR);
+#else
+    int loopDirLen = sizeof(Volume::LOOPDIR);
+#endif
     char loopDir[loopDirLen + 2];
     strcpy(loopDir, Volume::LOOPDIR);
     loopDir[loopDirLen++] = '/';
@@ -1473,7 +1477,7 @@ bool VolumeManager::isMountpointMounted(const char *mp)
     fclose(fp);
     return false;
 }
-
+#ifndef STE_HARDWARE
 int VolumeManager::cleanupAsec(Volume *v, bool force) {
     int rc = unmountAllAsecsInDir(Volume::SEC_ASECDIR_EXT);
 
@@ -1506,4 +1510,27 @@ int VolumeManager::cleanupAsec(Volume *v, bool force) {
     return rc;
 
 }
-
+#else
+int VolumeManager::cleanupAsec(Volume *v, bool force) {
+    while(mActiveContainers->size()) {
+        AsecIdCollection::iterator it = mActiveContainers->begin();
+        ContainerData* cd = *it;
+        SLOGI("Unmounting ASEC %s (dependant on %s)", cd->id, v->getMountpoint());
+        if (cd->type == ASEC) {
+            if (unmountAsec(cd->id, force)) {
+                SLOGE("Failed to unmount ASEC %s (%s)", cd->id, strerror(errno));
+                return -1;
+            }
+        } else if (cd->type == OBB) {
+            if (unmountObb(cd->id, force)) {
+                SLOGE("Failed to unmount OBB %s (%s)", cd->id, strerror(errno));
+                return -1;
+            }
+        } else {
+            SLOGE("Unknown container type %d!", cd->type);
+            return -1;
+        }
+    }
+    return 0;
+}
+#endif
diff --git a/system/vold/VolumeManager.h b/system/vold/VolumeManager.h
index 198b5a9..0515366 100644
--- a/system/vold/VolumeManager.h
+++ b/system/vold/VolumeManager.h
@@ -116,9 +116,9 @@ public:
     int mountObb(const char *fileName, const char *key, int ownerUid);
     int unmountObb(const char *fileName, bool force);
     int getObbMountPath(const char *id, char *buffer, int maxlen);
-
+#ifndef STE_HARDWARE
     Volume* getVolumeForFile(const char *fileName);
-
+#endif
     /* Shared between ASEC and Loopback images */
     int unmountLoopImage(const char *containerId, const char *loopId,
             const char *fileName, const char *mountPoint, bool force);
